/**
 * Automation Runners
 *
 * Each runner implements the logic for a specific automation type.
 * They are invoked by the scheduler and return structured results.
 */

import type { Automation, AutomationRun } from 'types/automation'
import { generateTransactionsForEligibleContracts } from './transaction-generator'
import { sendAutomationCompletionEmail, sendAutomationErrorEmail } from './email-notifications'
import { createNotification } from './notification-service'

export interface RunnerResult {
  success: boolean
  summary: string
  metrics: Record<string, any>
  error?: string
}

/* ────────────────────────────────────────────────────────────
   A) Recurring Transaction Runner
   ──────────────────────────────────────────────────────────── */

async function runRecurringTransaction(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  const params = automation.parameters as any
  const templateExpenseId = params.templateExpenseId as string | undefined
  const templateTransactionId = params.templateTransactionId as string | undefined

  // Clone from expense template
  if (templateExpenseId) {
    const { data: template, error: fetchErr } = await supabase
      .from('house_expenses')
      .select('*')
      .eq('id', templateExpenseId)
      .single()

    if (fetchErr || !template) {
      return {
        success: false,
        summary: 'Template expense not found',
        metrics: {},
        error: fetchErr?.message || 'Template not found',
      }
    }

    const now = new Date()
    const { data: created, error: insertErr } = await supabase
      .from('house_expenses')
      .insert({
        organization_id: template.organization_id,
        house_id: template.house_id,
        direction: template.direction || 'expense',
        scope: template.scope || 'property',
        category: template.category,
        organisation_category: template.organisation_category,
        description: template.description,
        reference: template.reference,
        supplier: template.supplier,
        amount: template.amount,
        frequency: template.frequency,
        occurred_at: now.toISOString(),
        status: 'approved',
        notes: `Auto-generated by "${automation.name}"`,
        source: 'automation',
        automation_id: automation.id,
        automation_run_id: runId,
        template_expense_id: templateExpenseId,
      })
      .select('id')
      .single()

    if (insertErr) {
      return {
        success: false,
        summary: `Failed to create expense: ${insertErr.message}`,
        metrics: {},
        error: insertErr.message,
      }
    }

    return {
      success: true,
      summary: `Created expense from template: $${template.amount} – ${template.description}`,
      metrics: { createdExpenses: 1, amount: template.amount, expenseId: created?.id },
    }
  }

  // Clone from NDIS transaction template (income)
  if (templateTransactionId) {
    const { data: template, error: fetchErr } = await supabase
      .from('transactions')
      .select('*')
      .eq('id', templateTransactionId)
      .single()

    if (fetchErr || !template) {
      return {
        success: false,
        summary: 'Template transaction not found',
        metrics: {},
        error: fetchErr?.message || 'Template not found',
      }
    }

    // Generate next txn ID
    const orgId = template.organization_id
    const { data: nextIdResult } = await supabase.rpc('generate_next_txn_id', {
      p_organization_id: orgId,
    })
    const txnId = nextIdResult || `TXN-AUTO-${Date.now()}`

    const now = new Date()
    const { error: insertErr } = await supabase
      .from('transactions')
      .insert({
        id: txnId,
        resident_id: template.resident_id,
        contract_id: template.contract_id,
        organization_id: orgId,
        amount: template.amount,
        occurred_at: now.toISOString(),
        description: template.description,
        quantity: template.quantity,
        unit_price: template.unit_price,
        status: 'draft',
        drawdown_status: 'pending',
        is_drawdown_transaction: template.is_drawdown_transaction,
        created_by: 'automation-system',
        source: 'automation',
        automation_id: automation.id,
        automation_run_id_v2: runId,
        template_transaction_id: templateTransactionId,
      })

    if (insertErr) {
      return {
        success: false,
        summary: `Failed to create transaction: ${insertErr.message}`,
        metrics: {},
        error: insertErr.message,
      }
    }

    return {
      success: true,
      summary: `Created transaction from template: $${template.amount}`,
      metrics: { createdTransactions: 1, amount: template.amount, transactionId: txnId },
    }
  }

  return {
    success: false,
    summary: 'No template configured',
    metrics: {},
    error: 'Automation has no templateExpenseId or templateTransactionId in parameters',
  }
}

/* ────────────────────────────────────────────────────────────
   B) Contract Billing Run Runner
   ──────────────────────────────────────────────────────────── */

async function runContractBilling(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  const params = automation.parameters as any
  const notifyEmails: string[] = params.notifyEmails || []
  const timezone = automation.schedule.timezone || 'Australia/Sydney'

  try {
    const result = await generateTransactionsForEligibleContracts(
      timezone,
      automation.organizationId,
      true, // catchUpMode
      true, // useServiceRole
    )

    const summary = [
      `Contracts processed: ${result.processedContracts}`,
      `Successful: ${result.successfulTransactions}`,
      `Failed: ${result.failedTransactions}`,
      `Total: $${result.summary.totalAmount.toFixed(2)}`,
    ].join(' | ')

    // Send email if configured
    if (notifyEmails.length > 0 && result.successfulTransactions > 0) {
      try {
        // Fetch org name
        const { data: org } = await supabase
          .from('organizations')
          .select('name')
          .eq('id', automation.organizationId)
          .single()

        await sendAutomationCompletionEmail(notifyEmails, {
          organizationName: org?.name || 'Unknown',
          executionDate: new Date().toISOString(),
          executionTime: 0,
          processedContracts: result.processedContracts,
          successfulTransactions: result.successfulTransactions,
          failedTransactions: result.failedTransactions,
          totalAmount: result.summary.totalAmount,
          totalSuccessAmount: result.summary.totalAmount,
          totalFailedAmount: 0,
          transactions: [],
          errors: [],
          summary: result.summary,
          timezone,
        })
      } catch (emailErr) {
        console.error('[RUNNER:contract_billing] Email failed:', emailErr)
      }
    }

    // Create Haven notification
    if (result.successfulTransactions > 0) {
      try {
        await createNotification({
          organizationId: automation.organizationId,
          title: 'Automated Billing Complete',
          message: `Generated ${result.successfulTransactions} transaction${result.successfulTransactions > 1 ? 's' : ''} ($${result.summary.totalAmount.toFixed(2)})`,
          icon: result.failedTransactions > 0 ? '⚠️' : '✅',
          category: 'automation',
          priority: 'medium',
          actionUrl: '/transactions',
          metadata: { automationId: automation.id, runId },
        })
      } catch {
        // non-fatal
      }
    }

    return {
      success: result.failedTransactions === 0,
      summary,
      metrics: {
        processedContracts: result.processedContracts,
        successfulTransactions: result.successfulTransactions,
        failedTransactions: result.failedTransactions,
        totalAmount: result.summary.totalAmount,
      },
      error: result.failedTransactions > 0
        ? `${result.failedTransactions} contract(s) failed`
        : undefined,
    }
  } catch (err: any) {
    if (notifyEmails.length > 0) {
      try {
        await sendAutomationErrorEmail(notifyEmails, err.message, err)
      } catch {
        // non-fatal
      }
    }
    return {
      success: false,
      summary: `Contract billing failed: ${err.message}`,
      metrics: {},
      error: err.message,
    }
  }
}

/* ────────────────────────────────────────────────────────────
   Dispatcher
   ──────────────────────────────────────────────────────────── */

export async function executeRunner(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  switch (automation.type) {
    case 'recurring_transaction':
      return runRecurringTransaction(automation, runId, supabase)
    case 'contract_billing_run':
      return runContractBilling(automation, runId, supabase)
    default:
      return {
        success: false,
        summary: `Unknown automation type: ${automation.type}`,
        metrics: {},
        error: `Unsupported type: ${automation.type}`,
      }
  }
}


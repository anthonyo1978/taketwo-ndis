/**
 * Automation Runners
 *
 * Each runner implements the logic for a specific automation type.
 * They are invoked by the scheduler and return structured results.
 */

import type { Automation, AutomationRun, DailyDigestParams } from 'types/automation'
import { generateTransactionsForEligibleContracts } from './transaction-generator'
import { sendAutomationCompletionEmail, sendAutomationErrorEmail } from './email-notifications'
import { createNotification } from './notification-service'
import { aggregateDailyBrief, sendDailyBriefEmail } from './daily-brief'

export interface RunnerResult {
  success: boolean
  summary: string
  metrics: Record<string, any>
  error?: string
}

export interface PreflightResult {
  canRun: boolean
  reason: string
  warnings?: string[]
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   A) Recurring Transaction Runner
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function runRecurringTransaction(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  const params = automation.parameters as any
  const templateExpenseId = params.templateExpenseId as string | undefined
  const templateTransactionId = params.templateTransactionId as string | undefined

  // Clone from expense template
  if (templateExpenseId) {
    const { data: template, error: fetchErr } = await supabase
      .from('house_expenses')
      .select('*')
      .eq('id', templateExpenseId)
      .single()

    if (fetchErr || !template) {
      return {
        success: false,
        summary: 'Template expense not found',
        metrics: {},
        error: fetchErr?.message || 'Template not found',
      }
    }

    const now = new Date()
    const { data: created, error: insertErr } = await supabase
      .from('house_expenses')
      .insert({
        organization_id: template.organization_id,
        house_id: template.house_id,
        scope: template.scope || 'property',
        category: template.category,
        organisation_category: template.organisation_category,
        description: template.description,
        reference: template.reference,
        supplier: template.supplier,
        amount: template.amount,
        frequency: template.frequency,
        occurred_at: now.toISOString(),
        status: 'approved',
        notes: `Auto-generated by "${automation.name}"`,
        source: 'automation',
        automation_id: automation.id,
        automation_run_id: runId,
        template_expense_id: templateExpenseId,
      })
      .select('id')
      .single()

    if (insertErr) {
      return {
        success: false,
        summary: `Failed to create expense: ${insertErr.message}`,
        metrics: {},
        error: insertErr.message,
      }
    }

    return {
      success: true,
      summary: `Created expense from template: $${template.amount} â€“ ${template.description}`,
      metrics: { createdExpenses: 1, amount: template.amount, expenseId: created?.id },
    }
  }

  // Clone from NDIS transaction template (income)
  if (templateTransactionId) {
    const { data: template, error: fetchErr } = await supabase
      .from('transactions')
      .select('*')
      .eq('id', templateTransactionId)
      .single()

    if (fetchErr || !template) {
      return {
        success: false,
        summary: 'Template transaction not found',
        metrics: {},
        error: fetchErr?.message || 'Template not found',
      }
    }

    // Generate next txn ID
    const orgId = template.organization_id
    const { data: nextIdResult } = await supabase.rpc('generate_next_txn_id', {
      p_organization_id: orgId,
    })
    const txnId = nextIdResult || `TXN-AUTO-${Date.now()}`

    const now = new Date()
    const { error: insertErr } = await supabase
      .from('transactions')
      .insert({
        id: txnId,
        resident_id: template.resident_id,
        contract_id: template.contract_id,
        organization_id: orgId,
        amount: template.amount,
        occurred_at: now.toISOString(),
        description: template.description,
        quantity: template.quantity,
        unit_price: template.unit_price,
        status: 'draft',
        drawdown_status: 'pending',
        is_drawdown_transaction: template.is_drawdown_transaction,
        created_by: 'automation-system',
        source: 'automation',
        automation_id: automation.id,
        automation_run_id_v2: runId,
        template_transaction_id: templateTransactionId,
      })

    if (insertErr) {
      return {
        success: false,
        summary: `Failed to create transaction: ${insertErr.message}`,
        metrics: {},
        error: insertErr.message,
      }
    }

    return {
      success: true,
      summary: `Created transaction from template: $${template.amount}`,
      metrics: { createdTransactions: 1, amount: template.amount, transactionId: txnId },
    }
  }

  return {
    success: false,
    summary: 'No template configured',
    metrics: {},
    error: 'Automation has no templateExpenseId or templateTransactionId in parameters',
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   B) Contract Billing Run Runner
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function runContractBilling(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  const params = automation.parameters as any
  const notifyEmails: string[] = params.notifyEmails || []
  const timezone = automation.schedule.timezone || 'Australia/Sydney'

  try {
    const result = await generateTransactionsForEligibleContracts(
      timezone,
      automation.organizationId,
      true, // catchUpMode
      true, // useServiceRole
    )

    const summary = [
      `Contracts processed: ${result.processedContracts}`,
      `Successful: ${result.successfulTransactions}`,
      `Failed: ${result.failedTransactions}`,
      `Total: $${result.summary.totalAmount.toFixed(2)}`,
    ].join(' | ')

    // Send email if configured
    if (notifyEmails.length > 0 && result.successfulTransactions > 0) {
      try {
        // Fetch org name
        const { data: org } = await supabase
          .from('organizations')
          .select('name')
          .eq('id', automation.organizationId)
          .single()

        await sendAutomationCompletionEmail(notifyEmails, {
          organizationName: org?.name || 'Unknown',
          executionDate: new Date().toISOString(),
          executionTime: 0,
          processedContracts: result.processedContracts,
          successfulTransactions: result.successfulTransactions,
          failedTransactions: result.failedTransactions,
          totalAmount: result.summary.totalAmount,
          totalSuccessAmount: result.summary.totalAmount,
          totalFailedAmount: 0,
          transactions: [],
          errors: [],
          summary: result.summary,
          timezone,
        })
      } catch (emailErr) {
        console.error('[RUNNER:contract_billing] Email failed:', emailErr)
      }
    }

    // Create Haven notification
    if (result.successfulTransactions > 0) {
      try {
        await createNotification({
          organizationId: automation.organizationId,
          title: 'Automated Billing Complete',
          message: `Generated ${result.successfulTransactions} transaction${result.successfulTransactions > 1 ? 's' : ''} ($${result.summary.totalAmount.toFixed(2)})`,
          icon: result.failedTransactions > 0 ? 'âš ï¸' : 'âœ…',
          category: 'automation',
          priority: 'medium',
          actionUrl: '/transactions',
          metadata: { automationId: automation.id, runId },
        })
      } catch {
        // non-fatal
      }
    }

    return {
      success: result.failedTransactions === 0,
      summary,
      metrics: {
        processedContracts: result.processedContracts,
        successfulTransactions: result.successfulTransactions,
        failedTransactions: result.failedTransactions,
        totalAmount: result.summary.totalAmount,
      },
      error: result.failedTransactions > 0
        ? `${result.failedTransactions} contract(s) failed`
        : undefined,
    }
  } catch (err: any) {
    if (notifyEmails.length > 0) {
      try {
        await sendAutomationErrorEmail(notifyEmails, err.message, err)
      } catch {
        // non-fatal
      }
    }
    return {
      success: false,
      summary: `Contract billing failed: ${err.message}`,
      metrics: {},
      error: err.message,
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   C) Daily Digest Runner
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function runDailyDigest(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  const params = automation.parameters as DailyDigestParams
  const timezone = automation.schedule.timezone || 'Australia/Sydney'
  const lookbackDays = params.lookbackDays ?? 1
  const forwardDays = params.forwardDays ?? 7
  const recipientEmails = params.recipientEmails

  try {
    // 1. Aggregate data
    const briefData = await aggregateDailyBrief(
      automation.organizationId,
      supabase,
      timezone,
      lookbackDays,
      forwardDays,
      recipientEmails,
    )

    // 2. Send email
    const emailResult = await sendDailyBriefEmail(briefData)

    // 3. Create Haven notification
    try {
      await createNotification({
        organizationId: automation.organizationId,
        title: 'â˜€ï¸ Daily Brief Sent',
        message: `Net yesterday: $${briefData.yesterday.net.toFixed(2)} Â· Sent to ${emailResult.recipientCount} admin${emailResult.recipientCount !== 1 ? 's' : ''}`,
        icon: 'ğŸ“Š',
        category: 'automation',
        priority: 'low',
        actionUrl: '/dashboard',
        metadata: { automationId: automation.id, runId },
      })
    } catch {
      // non-fatal
    }

    const summary = [
      `Net yesterday: $${briefData.yesterday.net.toFixed(2)}`,
      `Income: $${briefData.yesterday.income.toFixed(2)}`,
      `Costs: $${(briefData.yesterday.propertyCosts + briefData.yesterday.orgCosts).toFixed(2)}`,
      `Sent to ${emailResult.recipientCount} admin(s)`,
      emailResult.error ? `Email note: ${emailResult.error}` : '',
    ].filter(Boolean).join(' | ')

    return {
      success: emailResult.success || emailResult.recipientCount === 0,
      summary,
      metrics: {
        income: briefData.yesterday.income,
        propertyCosts: briefData.yesterday.propertyCosts,
        orgCosts: briefData.yesterday.orgCosts,
        net: briefData.yesterday.net,
        recipientCount: emailResult.recipientCount,
        alertCount: briefData.alerts.expiringContracts.length
          + briefData.alerts.failedAutomations.length
          + briefData.alerts.lowBalanceContracts.length,
      },
      error: emailResult.success ? undefined : emailResult.error,
    }
  } catch (err: any) {
    console.error('[RUNNER:daily_digest] Error:', err)
    return {
      success: false,
      summary: `Daily Brief failed: ${err.message}`,
      metrics: {},
      error: err.message,
    }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Preflight Checks
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

async function preflightRecurringTransaction(
  automation: Automation,
  supabase: any,
): Promise<PreflightResult> {
  const params = automation.parameters as any
  const templateExpenseId = params.templateExpenseId as string | undefined
  const templateTransactionId = params.templateTransactionId as string | undefined

  if (!templateExpenseId && !templateTransactionId) {
    return {
      canRun: false,
      reason: 'No template configured. This automation has no templateExpenseId or templateTransactionId in its parameters.',
    }
  }

  if (templateExpenseId) {
    const { data: template, error } = await supabase
      .from('house_expenses')
      .select('id, description, amount, status')
      .eq('id', templateExpenseId)
      .single()

    if (error || !template) {
      return {
        canRun: false,
        reason: `Template expense not found (${templateExpenseId}). It may have been deleted.`,
      }
    }

    if (template.status === 'cancelled') {
      return {
        canRun: false,
        reason: `Template expense "${template.description}" has been cancelled. Re-enable or choose a different template.`,
      }
    }

    return {
      canRun: true,
      reason: `Ready to clone expense "${template.description}" ($${template.amount}).`,
    }
  }

  if (templateTransactionId) {
    const { data: template, error } = await supabase
      .from('transactions')
      .select('id, description, amount')
      .eq('id', templateTransactionId)
      .single()

    if (error || !template) {
      return {
        canRun: false,
        reason: `Template transaction not found (${templateTransactionId}). It may have been deleted.`,
      }
    }

    return {
      canRun: true,
      reason: `Ready to clone transaction "${template.description || templateTransactionId}" ($${template.amount}).`,
    }
  }

  return { canRun: false, reason: 'Unknown template configuration.' }
}

async function preflightContractBilling(
  automation: Automation,
  supabase: any,
): Promise<PreflightResult> {
  const warnings: string[] = []

  // Check org exists
  const { data: org, error: orgErr } = await supabase
    .from('organizations')
    .select('id, name')
    .eq('id', automation.organizationId)
    .single()

  if (orgErr || !org) {
    return {
      canRun: false,
      reason: 'Organisation not found. Cannot run contract billing.',
    }
  }

  // Check there are active contracts
  const { count, error: countErr } = await supabase
    .from('funding_contracts')
    .select('id', { count: 'exact', head: true })
    .eq('organization_id', automation.organizationId)
    .eq('status', 'active')

  if (countErr) {
    return {
      canRun: false,
      reason: `Failed to check contracts: ${countErr.message}`,
    }
  }

  if (!count || count === 0) {
    return {
      canRun: false,
      reason: 'No active funding contracts found. There is nothing to bill.',
    }
  }

  return {
    canRun: true,
    reason: `Ready to process ${count} active contract${count > 1 ? 's' : ''} for ${org.name}.`,
    warnings: warnings.length > 0 ? warnings : undefined,
  }
}

async function preflightDailyDigest(
  automation: Automation,
  supabase: any,
): Promise<PreflightResult> {
  const params = automation.parameters as DailyDigestParams

  // Check org exists
  const { data: org, error: orgErr } = await supabase
    .from('organizations')
    .select('id, name')
    .eq('id', automation.organizationId)
    .single()

  if (orgErr || !org) {
    return { canRun: false, reason: 'Organisation not found.' }
  }

  const warnings: string[] = []

  // Determine recipients
  const explicitRecipients = (params.recipientEmails || []).filter(Boolean)

  if (explicitRecipients.length > 0) {
    // Explicit recipients configured â€” validate they look like emails
    const invalid = explicitRecipients.filter(e => !e.includes('@'))
    if (invalid.length > 0) {
      warnings.push(`${invalid.length} recipient${invalid.length > 1 ? 's look' : ' looks'} like an invalid email.`)
    }

    if (!process.env.RESEND_API_KEY) {
      warnings.push('RESEND_API_KEY is not configured â€” email will not actually send.')
    }

    return {
      canRun: true,
      reason: `Ready to generate Daily Brief for ${org.name} and send to ${explicitRecipients.length} configured recipient${explicitRecipients.length > 1 ? 's' : ''}.`,
      warnings: warnings.length > 0 ? warnings : undefined,
    }
  }

  // No explicit recipients â€” fall back to all org admins
  const { count, error: countErr } = await supabase
    .from('users')
    .select('id', { count: 'exact', head: true })
    .eq('organization_id', automation.organizationId)
    .eq('role', 'admin')
    .eq('status', 'active')

  if (countErr) {
    return { canRun: false, reason: `Failed to check admin users: ${countErr.message}` }
  }

  if (!count || count === 0) {
    return {
      canRun: false,
      reason: 'No recipients configured and no active admin users found. Add at least one recipient email.',
    }
  }

  if (!process.env.RESEND_API_KEY) {
    warnings.push('RESEND_API_KEY is not configured â€” email will not actually send.')
  }

  return {
    canRun: true,
    reason: `Ready to generate Daily Brief for ${org.name} and send to ${count} admin${count > 1 ? 's' : ''} (no specific recipients configured â€” using all admins).`,
    warnings: warnings.length > 0 ? warnings : undefined,
  }
}

/**
 * Run a preflight check to determine if an automation can safely execute.
 * Use this before "Run Now" to give users meaningful feedback.
 */
export async function preflightCheck(
  automation: Automation,
  supabase: any,
): Promise<PreflightResult> {
  switch (automation.type) {
    case 'recurring_transaction':
      return preflightRecurringTransaction(automation, supabase)
    case 'contract_billing_run':
      return preflightContractBilling(automation, supabase)
    case 'daily_digest':
      return preflightDailyDigest(automation, supabase)
    default:
      return {
        canRun: false,
        reason: `Unknown automation type: ${automation.type}`,
      }
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Dispatcher
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

export async function executeRunner(
  automation: Automation,
  runId: string,
  supabase: any,
): Promise<RunnerResult> {
  switch (automation.type) {
    case 'recurring_transaction':
      return runRecurringTransaction(automation, runId, supabase)
    case 'contract_billing_run':
      return runContractBilling(automation, runId, supabase)
    case 'daily_digest':
      return runDailyDigest(automation, runId, supabase)
    default:
      return {
        success: false,
        summary: `Unknown automation type: ${automation.type}`,
        metrics: {},
        error: `Unsupported type: ${automation.type}`,
      }
  }
}

